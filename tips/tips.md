## 数え上げ

### ヒント

* 配列の長さが40程度であれば、半分全列挙を疑う (meet in the middle)
  * 2^40の全列挙は無理だが2^20の全列挙は可能

### 実例

* [C: String Coloring \- AtCoder Grand Contest 026 \| AtCoder](https://agc026.contest.atcoder.jp/tasks/agc026_c)
  * 問題
    * 

## 部分配列

配列の中から条件を満たす最高の配列を見つける系の問題。

### ヒント

* 配列の長さが10^5であれば、以下ができないか考える
  * 部分配列の左端を固定したとき、部分配列の右端をlog n以下で決定することができないか？
  * しゃくとり法(two-pointers)は適用できないか？
  * 転倒数の算出（BITを使い、これまでに出た要素の累積和を管理）の類題として解けないか？
    * 例: 和が０以上になる連続部分列の数 (bit_app.hに実装あり)


### 実例

以下はすべてしゃくとり法で解ける。

* POJ No. 3061 (蟻本 p135)
  * 問題
    * 総和がS以上になる部分配列のうち、最小の長さは？
* POJ No. 3320 (蟻本 p137)
  * 問題
    * すべての要素が最低一度は出現する部分配列のうち、最小の長さは？
* [Dashboard \- Kickstart Round D 2018 \- Google Code Jam](https://code.google.com/codejam/contest/6364486/dashboard#s=p0&a=2)
  * 問題
    * 奇数の要素数がO以下、かつ、要素の合計数がD以下、という条件で、要素の合計数が最大となる部分配列を見つける
    * 配列の長さ10^5


## 木

### ヒント

* 適当なノードをrootにして根付き木にしてみる。木DPが適用できるかも。


## 桁DP

### ヒント 

### 実例

* https://kotamanegi.com/Problems/view/?page=72
  * 問題
    * 桁和がNとなる数の中でK番目に小さい数を求める
  * 解法
    * 先頭に0が並ぶことを許容すれば、「桁数がdで桁和がNになる数の総数」を求めるのはDPで容易にできる。
    * あとは "1", "2", ..., "9", "1X", "2X", ..., "9X", "1XX", "2XX", ..., "9XX"と先頭の数字を固定しながらXXが取りうる数をカウントし、Kから引いていく


## 構築系

### ヒント

* 任意の数をいくつかの数で構築
  * 1, 2, 4, 8, ...と2のべき乗の要素を考えるとよい
  * 例： 4つの数を足し引きすることで、1, 3, 5, 7, ..., 15までの全奇数を作れ
    * 1, 2, 4, 8の数を用意する
    * 7を作りたい場合, + 8 - 4  + 2 + 1 と、目標数に近くなるよう大きい数から順番に符号を決めていける
    * c.f. Robot Arms  https://atcoder.jp/contests/arc103/tasks/arc103_b
  * 例： 5つの数を足し引きすることで、0, 2, 4, 6, ..., 16までの全偶数を作れ
    * 1, 1, 2, 4, 8の数を用意する
    * 6を作りたい場合, + 8 - 4 + 2 + 1 - 1


## 区間

### ヒント

* １次元座標中に始点・終点をもつ区間がたくさんある場合、始点をX軸、終点をY軸として区間を点としてプロット
  * 例: [AtCoder Express 2](https://atcoder.jp/contests/abc106/tasks/abc106_d)


## データ構造

### Union Find

データ構造に手を入れる例

* [Union and Query](https://yukicoder.me/problems/no/1054/editorial)
    * 問題: 頂点を結合するクエリ、結合された頂点のすべてに値Bを足すクエリを処理
    * 

## 頻出のテーマ

### パスカルの三角形

```
           1
         1   1
       1   2   1
     1   3   3   1
   1   4   6   4   1
 1   5  10  10   5   1
```
* 上から n 段目、左から k 番目の数は、C(n-1, k-1)
    * 経路数として解釈することができる。例えば図の6は、4回移動するうち左への移動を2回、右への移動を2回する経路数の合計として解釈できる
    * n行目は、(a+b)^(n-1)を展開したときの係数になっている
* C(n, k) = C(n - 1, k - 1) + C(n - 1, k)を満たす
* 各行の和は1, 2, 4, 8, ...とべき乗になっている
    * c.f. GCJ 2020 Round 1B B問題
* すべての数を2で割るとフラクタル構造が現れる。3で割っても同様

```
           1
        (1)  1
       1  (2)  1
     1   3  (3)  1
   1   4   6  (4)  1
 1   5  10 (10)  5   1
```

* 上の(10)は、(1)..(4)を全部足した値になっている
    * 経路数として解釈するとわかりやすい。(10)にたどり着くためには、(1)..(4)のいずれか1つのみを必ず通る必要がある
